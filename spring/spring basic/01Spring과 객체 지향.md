# Spring Basic
## 스프링 프레임워크
- 핵심 기술 : DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술 : 스프링 MVC, WebFlux
- 기술통합 : 캐시, 이메일, 원격접근, 스케쥴링
- 테스트 : 스프링 기반 테스트 지원(Junit, mockito)
- 언어 : 코틀린, 그루비
## 스프링 부트 
- 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- 톰캣같은 웹 서버 내장 -> 별도의 웹서버를 설치할 필요가 없다.
- 손쉬운 빌드 구성
- 스프링과 외부 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성같은 프로덕션 준비 기능 제공
- 간결한 설정
## 스프링은 왜 만들어졌는가?
스프링은 Java언어 기반의 프레임워크이다.

Java의 가장 큰 특징은 무엇인가?

바로 **객체 지향** 이다.

> 스프링은 Java의 객체 지향 특징을 가장 강력하게 살릴 수 있는 프레임워크이다.

## 좋은 객체 지향 프로그래밍이란?
### 객체지향의 특징
- 추상화
- 캡슐화
- 상속
- **다형성**

### 객체 지향 프로그래밍
- 객체 지향 프로그래밍은 컴퓨터 프로그램을 **객체**들의 모임으로 파악한다.
- 각각의 객체들은 서로 메시지를 주고 받고, 데이터를 처리할 수 있다.(협력)
- 객체 지향 프로그래밍은 유연하고 변경에 용이한 개발을 가능하게 한다.

## 다형성 - Polymorphism
### 다형성?
세상을 역할과 구현으로 구분한다.
### Ex
- 운전
<img width="536" alt="스크린샷 2023-02-15 오전 12 05 19" src="https://user-images.githubusercontent.com/97084128/218777200-b8cb9730-cb5b-4f30-839b-4b4cd7bcf299.png">

- 공연
<img width="574" alt="스크린샷 2023-02-15 오전 12 08 10" src="https://user-images.githubusercontent.com/97084128/218777456-350db746-72c1-41c8-b74a-978e7c0857c6.png">

### 역할과 구현을 분리
- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
- 내부 구조가 변경되어도 클라이언트에는 영향이 없다.
- 구현 대상을 변경해도 클라이언트에는 영향이 없다.

### 역할과 구현을 분리 - Java
- 역할 = 인터페이스
- 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체 설계 시 역할과 구현을 명확하게 분리
- 인터페이스를 먼저 부여하고, 그것을 구현하는 구현 객체 만들기

### 자바에서의 다형성 - 오버라이딩
<img width="376" alt="스크린샷 2023-02-15 오전 12 12 31" src="https://user-images.githubusercontent.com/97084128/218778546-7c8ae024-5f8c-46ce-ba72-2b100f010c72.png">

- 오버라이딩된 메서드가 실행됨.
- 인터페이스의 구현체를 변경해도 클라이언트(서비스)에는 영향이 없음.

## 다형성의 본질
- 인터페이스를 구현한 객체 인스턴스를 실행시점에 유연하게 변경할 수 있다.
- **클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.**

## 역할과 구현 분리 - 정리
- 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음 
- 유연하고, 변경이 용이
- 확장 가능한 설계
- 클라이언트에 영향을 주지 않는 변경 가능
인터페이스를 안정적으로 잘 설계하는 것이 중요

## 역할과 구현 분리 - 한계
- 인터페이스, 즉 역할 자체에 변화가 생기면, 클라이언트와 서버 모두에 큰 변경이 발생한다.
- 따라서 인터페이스를 잘 설계하는 것이 중요하다.

## 스프링 - 객체 지향
스프링에서의 IoC(제어의 역전)와 DI(의존관계 주입)는 자바의 다형성을 활용하여 역할과 구현을 편리하게 다룰 수 있도록 지원한다.

## 객체 지향 설계의 5가지 원직 - SOLID
- SRP: 단일 책임 원칙(single responsibility principle)
- OCP: 개방-폐쇄 원칙 (Open/closed principle)
- LSP: 리스코프 치환 원칙 (Liskov substitution principle) 
- ISP: 인터페이스 분리 원칙 (Interface segregation principle) 
- DIP: 의존관계 역전 원칙 (Dependency inversion principle)
### SRP 단일 책임 원칙
- Single responsibility principle
- 하나의 클래스는 하나의 책임만 가진다.
- **중요한 기준은 변경**
  - 변경이 있을 때 파급효과가 적을수록 단일 책임 원칙을 잘 따른 것이다.

### OCP 개방-폐쇄 원칙
- Open/closed principle
- 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
- 새로운 기능을 추가 시, 기존 인터페이스를 구현한 새로운 클래스를 만들어 구현체만 바꿔주면 된다.

### LSP 리스코프 치환 원칙
- Liskov substitution principle
- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하기 위해선 이 원칙이 필요하다.
- ex) 자동차 인터페이스의 엑셀은 앞으로 가는 기능이다. 만약 엑셀을 뒤로 가도록 구현하면 해당 원칙을 위반한 것이다.

### ISP 인터페이스 분리 원칙
- Interface segregation principle
- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 자동차 인터페이스 -> 운전과 정비 인터페이스로 분리
- 사용자 클라이언트 -> 운전자, 정비사 클라이언트로 분리
- 분리하면 어느 한 쪽의 인터페이스 자체가 변해도 다른 인터페이스에 전혀 영향을 주지 않는다.
- 인터페이스의 정의가 명확해지고, 대체 가능성이 높아진다.

### DIP 의존관계 역전 원칙
- Dependency inversion principle
- **개발자는 추상화에 의존해야 한다. 구체화에 의존해서는 안된다.**
  -> 구현 클래스에 의존하는 것이 아닌, 인터페이스에 의존하라
- 구현이 아닌 역할에 의존하도록 하라
- 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.
