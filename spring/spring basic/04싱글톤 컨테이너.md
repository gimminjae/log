## 웹 애플리케이션과 싱글톤
- 스프링은 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다.
- 스프링으로는 대부분 웹 애플리케이션을 개발한다.
- 웹 애플리케이션에서는 보통 여러 명의 고객이 동시간에 요청을 한다.
![스크린샷 2023-02-18 오후 3 10 21](https://user-images.githubusercontent.com/97084128/219844331-8cfae569-1f21-4495-a267-04307047b174.png)
- 예전의 스프링이 없는 순수한 DI 컨테이너 에서는 위의 이미지처럼 새로운 요청이 있을 때마다 객체를 새로 생성해 응답했다.
- 1초에 100명의 고객이 요청을 보내면 1초에 100개의 같은 객체가 생성되는 것이다. -> 심한 메모리 낭비
- 해결방안은 처음에 객체를 딱 하나 만들고 그 객체가 여러 고객의 같은 요청에 응답하도록 하면 된다.(재사용) -> 이것이 싱글톤 패턴이다.

## 싱글톤 패턴
- 하나의 클래스에 대해서는 딱 하나의 인스턴스만 생성되는 것을 보장해야 한다.
- 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막기 위해서 private 생성자를 사용해야 한다. -> 외부에서 new 등의 연산으로 인스턴스를 생성하지 못하도록

## 싱글톤 패턴 예제
```
public class SingletonService {
  //1. static 영역에 객체를 딱 1개만 생성해둔다.
  private static final SingletonService instance = new SingletonService();
  //2. public으로 열어서 객체 인스터스가 필요하면 이 static 메서드를 통해서만 조회하도록 허용한다.
  public static SingletonService getInstance() {
      return instance;
  }
  //3. 생성자를 private으로 선언해서 외부에서 new 키워드를 사용한 객체 생성을 못하게 막는다. 
  private SingletonService() {
  }
  public void logic() { 
      System.out.println("싱글톤 객체 로직 호출");
  } 
}
```
1. 정적(static) 영역에 인스턴스를 하나 생성한다.
2. 이 클래스의 인스턴스가 필요하면 getInstance() 메서드를 통해서만 얻을 수 있다. -> getInstance는 항상 같은 인스턴스를 반환한다.
3. 단 하나의 인스턴스만 존재해야 하므로 private 생성자로 new를 통한 인스턴스 생성을 막는다.

## 싱글톤 패턴의 문제점
- 싱글톤 패턴을 구현하는 데에 코드가 많이 작성되어야 한다.
- 의존관계상 클라이언트가 구체 클래스에 의존한다. -> DIP 위반
- 클라이언트가 구체 클래스에 의존해 OCP 원칙을 위반할 가능성이 있다.
- 테스트가 어렵다.
- 내부 속성을 변경하기가 어렵다.
- private 생성자로 자식 클래스를 만들기가 어렵다.
- 유연성이 떨어진다.

## 싱글톤 컨테이너
스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리한다.

- 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
- 스프링 컨테이너는 생성시에, 각각 하나의 인스턴스를 생성해 관리한다.
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다.
- 싱글톤 패턴 구현을 위한 코드가 들어가지 않아도 된다.
- DIP, OCP, 테스트, private생성자로부터 자유롭게 싱글톤을 사용할 수 있다.
- 싱글톤 컨테이너 적용 후
![스크린샷 2023-02-18 오후 3 31 25](https://user-images.githubusercontent.com/97084128/219845170-dd153946-d6d5-48c6-b815-704e60c0e055.png)

## 싱글톤의 주의점
- 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지하게 설계하면 안된다.
- 무상태(stateless)로 설계해야 한다.
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, threadLocal 등을 사용해야 한다.
  - 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다.

```java
public class StatefulService {
  private int price //상태를 유지하는 필드
  
  public void order(String name, int price) {
    System.out.println("name = " + name + " price = " + price);
    this.price = price; //여기서 문제가 발생!
  }
  public int getPrice() {
    return price;
  }
}
```

- StatefulService의 price는 공유되는 필드이다.(상태가 유지되는 필드)
- 그런데, 이 필드의 값을 클라이어트가 변경 가능하다.
- 이러한 상태를 유지하는(공유 필드) 필드 때문에 해결하기 어려운 문제가 발생할 수 있다.
- 스프링 빈은 항상 **무상태(stateless)**로 설계하자.

## Configuration 과 싱글톤, 스프링의 바이트코드 조작
- 우리는 설정파일인 AppConfig를 등록하고 스프링 빈을 등록할 때, @Configuration, @Bean 등의 어노테이션을 사용한다.
- 하지만, AppConfig와 빈들이 그대로 스프링 컨테이너에 등록되는 것이 아니다.
- 우리가 빈으로 등록한 AppConfig와 객체들을 상속하는 또다른 임의의 클래스를 만들고, 그 클래스를 스프링 빈으로 등록한다.
- ![스크린샷 2023-02-20 오후 9 54 17](https://user-images.githubusercontent.com/97084128/220114323-133868a6-883f-494f-b488-7264d0cb2ae8.png)
- 우리가 등록한 빈들을 아래와 같이 코드가 변화될 것이다.
```java
@Bean
public MemberRepository memberRepository() {
  if(memoryMemberRepository가 이미 스프링 컨테이너 등록되어 있으면) {
    return 스프링 컨테이너에서 찾아 반환;
  } else {
    기존 로직을 호출, 생성 후 등록
    return 반환;
  }
}
```
- @Bean이 붙은 코드들마다 이미 스프링 빈이 등록되 있다면 존재하는 빈을 반환하고, 스프링 빈이 없으면 새로 생성후 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다.
- 이로 인해 싱글톤이 보장된다.
